# -*- coding: utf-8 -*-import arcpyimport mathimport numpy as npimport laspy as lpimport pandas as pdimport geopandas as gpdimport warningsimport oswarnings.filterwarnings("ignore", category=DeprecationWarning)arcpy.env.overwriteOutput = Trueclass Toolbox(object):    def __init__(self):        """Minimum yet optimal (MYO) camera stations for UAS image collections of utility        infrastructure."""        self.label = "MYOModel"        self.alias = "MYOModel"        # List of tool classes associated with this toolbox        self.tools = [MYOModelTool, SimilarStructure]class MYOModelTool(object):    def __init__(self):        """Determine minimum yet optimal camera stations based on line of sight and obstructions."""        self.label = "Run MYOModel"        self.description = "Determine minimum yet optimal camera stations based on line of sight and obstructions."        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        input_targets = arcpy.Parameter(            displayName="Input Targets",            name="input_targets",            datatype="DEFeatureClass",            parameterType="Required",            direction="Input")        input_point_cloud = arcpy.Parameter(            displayName="Input Point Cloud",            name="input_point_cloud",            datatype="DELasDataset",            parameterType="Required",            direction="Input")        input_spatial_reference = arcpy.Parameter(            displayName="Input Coordinate System",            name="input_spatial_reference",            datatype="GPCoordinateSystem",            parameterType="Required",            direction="Input")        project_geodatabase = arcpy.Parameter(            displayName="Input Project GeoDatabase",            name="project_geodatabase",            datatype="DEWorkspace",            parameterType="Required",            direction="Input")        project_geodatabase.filter.list = ["Local Database"]        project_geodatabase_wgs84 = arcpy.Parameter(            displayName="Input Project GeoDatabase (WGS84)",            name="project_geodatabase_wgs84",            datatype="DEWorkspace",            parameterType="Required",            direction="Input")        project_geodatabase_wgs84.filter.list = ["Local Database"]        input_las_voxel_size = arcpy.Parameter(            displayName="Input Desired Point Cloud Voxel Size (Meters)",            name="input_las_voxel_size",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_camera_station_voxel_size = arcpy.Parameter(            displayName="Input Desired Camera Station Voxel Size (Meters)",            name="input_camera_station_voxel_size",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_sensor_width = arcpy.Parameter(            displayName="Input Sensor Width (Meters)",            name="input_sensor_width",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_sensor_height = arcpy.Parameter(            displayName="Input Sensor Height (Meters)",            name="input_sensor_height",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_focal_length = arcpy.Parameter(            displayName="Input Focal Length (Meters)",            name="input_focal_length",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_image_width = arcpy.Parameter(            displayName="Input Image Width (pixels)",            name="input_image_width",            datatype="GPLong",            parameterType="Required",            direction="Input")        input_image_height = arcpy.Parameter(            displayName="Input Image Height (pixels)",            name="input_image_height",            datatype="GPLong",            parameterType="Required",            direction="Input")        params = [input_targets, input_point_cloud, input_spatial_reference, project_geodatabase,                  project_geodatabase_wgs84, input_las_voxel_size, input_camera_station_voxel_size,                  input_sensor_width, input_sensor_height, input_focal_length, input_image_width, input_image_height]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool. MYOModel executes functions as follows:        1) Load targets from target shapefile with "load_targets()"        2) Load the point cloud into a pandas dataframe with pandas and laspy        3) Center in local coordinates the point cloud and targets with "center_points()"        4) Create a spherical point cloud around each target to be used as potential camera waypoints with            "create_feature_cloud()" and determine sensor distance with "calculate_sensor_distance()        5) Subsample the potential camera waypoints from the spherical point clouds with "target_subsampling()"        6) Uncenter all potential camera stations back to geographic coordinates with "uncenter_points()"        7) Check all primary targets' potential camera waypoints for obstructions with "check_visibility()"        8) Check visible camera waypoints for views of non-primary targets with "check_cumulative()"        9) Output individual primary targets' and cumulative-view targets' visible camera waypoints to WGS 84 projection with            "export_to_wgs84()"        10) Select and output just the center-most individual primary targets' camera waypoints with            "find_unique_cam_target_views()" and "find_3d_center_point()        11) Select and output the cumulative-view targets' waypoints with the most secondary views and ensure the least            number of camera waypoints are output while ensuring that every target receives at least one camera waypoint            with "prepare_cumulative_count()", "calculate_cumulative_station_count()", and            "extract_cumulative_waypoints()"        12) Merge the selected individual and cumulative camera waypoints with "merge_selected_stations()"        The tool returns "camera_waypoints" to the WGS84 Geodatabase with camera waypoints that can be used in flight        planning software for collecting all targets with unobstructed views using the fewest number of waypoints        possible"""        warnings.filterwarnings("ignore", category=DeprecationWarning)        # Load parameters from ArcGIS into python-friendly variables        target_file = parameters[0].ValueAsText        las_input_file = parameters[1].ValueAsText        spatial_reference = parameters[2].ValueAsText        geodatabase_name = parameters[3].ValueAsText        new_geodatabase_name = parameters[4].ValueAsText        las_voxel_size = float(parameters[5].ValueAsText)        camera_station_voxel_size = float(parameters[6].ValueAsText)        sensor_width = float(parameters[7].ValueAsText)        sensor_height = float(parameters[8].ValueAsText)        focal_length = float(parameters[9].ValueAsText)        image_width = int(parameters[10].ValueAsText)        image_height = int(parameters[11].ValueAsText)        # Set Static Parameters        angular_resolution = 0.4        average_point_spacing = "0.5"        elevation_field = "Shape.Z"        # Load the LAS point cloud into a pandas dataframe        las_file = lp.file.File(las_input_file, mode="r")        las_points = np.vstack((las_file.x, las_file.y, las_file.z, las_file.Classification)).transpose()        las_points_data_frame = pd.DataFrame(data=las_points, columns=["x", "y", "z", "class"])        las_points_data_frame = las_points_data_frame.to_records(index=False)        def load_targets(shapefile):            """            Function to load a shapefile and return a numpy array            :param shapefile: path to the input targets shapefile            :type shapefile: str            :return: target_points: an array containing x, y, z, gsd, azimuth min, azimuth max, pitch min, pitch max            :rtype: np.ndarray            """            features_dataframe = gpd.read_file(shapefile)            features_list = []            for index, values in features_dataframe.sort_values(by=['ViewID']).iterrows():                x, y, z, gsd, azmin, azmax, pmin, pmax = features_dataframe.loc[index].geometry.x, \                                                         features_dataframe.loc[index].geometry.y, \                                                         features_dataframe.geometry.loc[index].z, \                                                         features_dataframe.loc[index].gsd, \                                                         features_dataframe.loc[index].azmin, features_dataframe.loc[                                                             index].azmax, \                                                         features_dataframe.loc[index].pmin, features_dataframe.loc[                                                             index].pmax                features_list.append([x, y, z, gsd, azmin, azmax, pmin, pmax])            target_points = np.array(features_list)            return target_points        def center_points(point_cloud, new_x_center=None, new_y_center=None, new_z_center=None, features=False):            """            Function to center target points and point cloud around a central local coordinate instead of a geographic                coordinate            :param point_cloud: takes the lidar point cloud from las_points_data_frame, or the input targets from                target_points            :type point_cloud: np.ndarray            :param new_x_center: value to move input targets in longitudinal direction, not used for lidar point cloud            :type new_x_center: float            :param new_y_center: value to move input targets in latitudinal direction, not used for lidar point cloud            :type new_y_center: float            :param new_z_center: value to move input targets in elevation direction, not used for lidar point cloud            :type new_z_center: float            :param features: True indicates the input point_cloud is for input targets and new_x, new_y, and new_z are                not required            :type features: bool            :return: point_cloud_scaled: point cloud array shifted to local coordinates centered around 0,0,0            :rtype: np.ndarray            :return: new_x_center: the value used to move the point cloud in the longitudinal direction            :rtype: float            :return: new_y_center: the value used to move the point cloud in the latitudinal direction            :rtype: float            :return: new_z_center: the value used to move the point cloud in the elevation direction            :rtype: float            :return: scaler: an array containing new_x, new_y, and new_z            :rtype: np.ndarray            """            # Check for points with heights below 0 and set to 0            point_cloud = np.delete(point_cloud, (point_cloud[:, 2] < 0), axis=0)            if features == True:                scaler = np.array(([new_x_center, new_y_center, new_z_center, 0, 0, 0, 0, 0]))                point_cloud_scaled = np.add(point_cloud, scaler)                point_cloud_scaled[:, 0:3] = point_cloud_scaled[:, 0:3] * 100                scaler = scaler[0:3]            else:                if point_cloud.shape[1] != 3:                    point_cloud = point_cloud[:, 0:3]                new_x_center = point_cloud[:, 0].min() * -1                new_y_center = point_cloud[:, 1].min() * -1                new_z_center = point_cloud[:, 2].min() * -1                scaler = np.array(([new_x_center, new_y_center, new_z_center]))                point_cloud_scaled = np.add(point_cloud, scaler)                point_cloud_scaled = point_cloud_scaled * 100            return point_cloud_scaled, new_x_center, new_y_center, new_z_center, scaler        def uncenter_points(point_cloud, original_scaler):            """            Function to move the lidar and target point clouds from local coordinates back to geographic coordinates            :param point_cloud: takes a point cloud as an ndarray            :type point_cloud: np.ndarray            :param original_scaler: takes a scaler from the center_points()            :type original_scaler: np.ndarray            :return: point_cloud_scaled: the point cloud returned to geographic coordinates            :rtype: np.ndarray            """            point_cloud_scaled = point_cloud / 100            original_scaler = original_scaler * -1            point_cloud_scaled = np.add(point_cloud_scaled, original_scaler)            return point_cloud_scaled        def target_subsampling(target_sphere_cloud, voxel_dim):            """            Function takes the spherical point cloud created for a target and returns points sampled from the camera            voxel size parameter            :param target_sphere_cloud: point cloud of potential camera stations for a target            :type target_sphere_cloud: np.ndarray            :param voxel_dim: the specified voxel size for the camera stations            :type voxel_dim: float            :return: target_grid_centers: the centroids of voxelized potential camera stations            :rtype: np.ndarray            """            camera_vox_dim = float(voxel_dim) * 100            non_empty_voxel_keys, inverse, nb_pts_per_voxel = np.unique(                ((target_sphere_cloud - np.min(target_sphere_cloud,                                               axis=0)) // camera_vox_dim), axis=0,                return_inverse=True, return_counts=True)            non_empty_voxel_keys = non_empty_voxel_keys.astype('int16')            inverse = inverse.astype('int16')            nb_pts_per_voxel = nb_pts_per_voxel.astype('int16')            idx_pts_vox_sorted = np.argsort(inverse)            voxel_grid = {}            grid_centers = []            last_seen = 0            for idx, vox in enumerate(non_empty_voxel_keys):                voxel_grid[tuple(vox)] = target_sphere_cloud[                    idx_pts_vox_sorted[last_seen:last_seen + nb_pts_per_voxel[idx]]]                grid_centers.append(                    voxel_grid[tuple(vox)][np.linalg.norm(voxel_grid[tuple(vox)] - np.mean(voxel_grid[tuple(vox)],                                                                                           axis=0), axis=1).argmin()])                last_seen += nb_pts_per_voxel[idx]            target_grid_centers = np.asarray(grid_centers)            return target_grid_centers        def convert_sphere_to_cart(center, radius, theta, phi):            """            Function to convert a spherical coordinate to cartesian            :param center: A list containing a cartesian coordinate (x, y, z)            :type center: list            :param radius: Value representing a distance from the camera station to the target            :type radius: float            :param theta: The theta angle coordinate            :type theta: float            :param phi: The phi angle coordinate            :type phi: float            :return: cartesian_points: the new x,y,z coordinate from the theta and phi coordinate            :rtype: np.ndarray            """            x = center[0] + radius * np.sin(theta) * np.cos(phi)            y = center[1] + radius * np.sin(theta) * np.sin(phi)            z = center[2] + radius * np.cos(theta)            cartesian_points = np.array([x, y, z]).T            return cartesian_points        def calculate_sensor_distance(gsd, focal, sensor_w, image_w):            """            Function to determine how far a potential camera waypoint is from a target            :param gsd: The desired ground sample distance for a target            :type gsd: float            :param focal: The focal length of the camera's sensor            :type focal: float            :param sensor_w: The physical width of the camera sensors' chip            :type sensor_w: float            :param image_w: The width of a camera image in pixels            :type image_w: int            :return: sensor_distance: the distance from the camera waypoint to the target            :rtype: float            """            sensor_distance = (gsd * focal * image_w) / sensor_w            return sensor_distance        def create_feature_cloud(target_point, angle_resolution, focal, sensor_w, image_w, sensor_h):            """            Function to create spherical point clouds of radius = distance from feature required to achieve a specific            ground sample distance. Point clouds must then be used with the las-based point cloud voxels for visibility            and cumulative analysis. CVA should further limit cumulative views to those with the same desired GSD.            :param target_point: A single target point (row) from the input targets shapefile            :type target_point: np.ndarray            :param angle_resolution: The desired angular distance between generated points            :type angle_resolution: float            :param focal: The focal length of the camera's sensor            :type focal: float            :param sensor_w: The physical width of the camera sensors' chip            :type sensor_w: float            :param image_w: The width of a camera image in pixels            :type image_w: int            :param sensor_h: The physical height of the camera sensors' chip            :type sensor_h: float            :return: cartesian_sphere: A spherical point cloud of potential camera waypoints for a target in cartesian                coordinates            :rtype: np.ndarray            :return: target_point: The target point used to create the spherical point cloud            :rtype: np.ndarray            :return: radius: The radius (camera waypoint distance) used for creating the point cloud            :rtype: float            """            angle_resolution = math.radians(angle_resolution)            feature_gsd = target_point[3]            target_point = target_point[0:3]            radius_m = calculate_sensor_distance(feature_gsd, focal, sensor_w, image_w)            radius = radius_m * 100            theta = np.arange(0, np.pi, step=angle_resolution)            cell_length = math.pi / (math.pi / angle_resolution)            num_cells = round(math.pi / cell_length)            num_decreases = np.round(num_cells * np.cos(theta))            theta_repeated = np.repeat(theta.astype('float'), np.abs(num_decreases.astype('int')))            num_decreases_repeated = np.repeat(np.abs(num_decreases.astype('int')), np.abs(num_decreases.astype('int')))            phi_repeated = np.ones_like(theta_repeated)            phi_repeated = (np.cumsum(phi_repeated) * (2 * (math.pi + angle_resolution) / num_decreases_repeated) - (                    2 * angle_resolution))            cartesian_sphere = convert_sphere_to_cart(target_point, radius, theta_repeated, phi_repeated)            check_neg_vals = np.logical_not(cartesian_sphere[:, 2] < 0)            cartesian_sphere = cartesian_sphere[check_neg_vals == True]            return cartesian_sphere, target_point, radius        def convert_points_to_feature_class(narray, output_fc, crs):            """            Function to turn the input points shapefile into an ESRI feature class in a geodatabase            :param narray: the input target points ndarray            :type narray: np.ndarray            :param output_fc: path to save the target points to in a geodatabase            :type output_fc: str            :param crs: A WKT-formatted coordinate system string that matches to original target shapefiles' system            :type crs: str            :return:            """            if narray.shape[1] > 3:                points_data_frame = pd.DataFrame(data=narray,                                                 columns=["x", "y", "z", "gsd", "azmin", "azmax", "pmin", "pmax"])                points_data_frame = points_data_frame.to_records(index=False)                arcpy.da.NumPyArrayToFeatureClass(in_array=points_data_frame, out_table=output_fc,                                                  shape_fields=("x", "y", "z"),                                                  spatial_reference=crs)            else:                points_data_frame = pd.DataFrame(data=narray, columns=["x", "y", "z"])                points_data_frame = points_data_frame.to_records(index=False)                arcpy.da.NumPyArrayToFeatureClass(in_array=points_data_frame, out_table=output_fc,                                                  shape_fields=("x", "y", "z"),                                                  spatial_reference=crs)        def export_to_wgs84(new_gdb, features, feature_type=None):            """            Function to convert feature classes from a projected coordinate system to WGS84 latitude/longitude/elevation            for possible use with a UAS.            :param new_gdb: The path to the WGS84 geodatabase            :type new_gdb: str            :param features: The path to a feature class in the non-WGS84 geodatabase            :type features: str or list            :param feature_type: "selected" is for individual primary target camera waypoints, "targets" is for the                camera waypoints for each target, "cumulative" is for the cumulative camera waypoint feature class            :type feature_type: str            :return:            """            sr = arcpy.SpatialReference(4326)            arcpy.env.outputCoordinateSystem = sr            if feature_type is "selected":                new_features_out_path = new_gdb                new_features_out_name = "selected_primary_views"                arcpy.conversion.FeatureClassToFeatureClass(in_features=features, out_path=new_features_out_path,                                                            out_name=new_features_out_name)                arcpy.management.AddXY(in_features=new_features_out_path + "/" + new_features_out_name)            elif feature_type is "targets":                count = 1                for i in features:                    new_features_out_path = new_gdb                    new_features_out_name = "target" + str(count) + "_camera_stations"                    arcpy.conversion.FeatureClassToFeatureClass(in_features=i, out_path=new_features_out_path,                                                                out_name=new_features_out_name)                    arcpy.management.AddXY(in_features=new_features_out_path + "/" + new_features_out_name)                    count += 1            elif feature_type is "cumulative":                new_features_out_path = new_gdb                new_features_out_name = "cumulative_camera_stations"                arcpy.conversion.FeatureClassToFeatureClass(in_features=features, out_path=new_features_out_path,                                                            out_name=new_features_out_name)                arcpy.management.AddXY(in_features=new_features_out_path + "/" + new_features_out_name)        def remove_near_targets(target_feature_class, las_multipoint_features):            temp_layer_name = "Temp_Multipoint_Layer"            output_las_multi = las_multipoint_features + "_NotNearTargets"            arcpy.CopyFeatures_management(las_multipoint_features, output_las_multi)            arcpy.MakeFeatureLayer_management(output_las_multi, temp_layer_name)            arcpy.management.SelectLayerByLocation(in_layer=temp_layer_name,                                                   overlap_type="WITHIN_A_DISTANCE_3D",                                                   select_features=target_feature_class,                                                   search_distance="6 Centimeters")            if int(arcpy.GetCount_management(temp_layer_name)[0]) > 0:                arcpy.DeleteFeatures_management(temp_layer_name)            return output_las_multi        def check_visibility(las_cloud, target_cloud, line_distance, target_feature, target_array, target_index,                             gdb_name, sensor_w, sensor_h, focal):            """            Function to check whether potential camera stations for each target are unobstructed            :param las_cloud: The path to the lidar-based point cloud used for determining obstructions            :type las_cloud: str            :param target_cloud: The path to the spherical point cloud of potential camera waypoints for a given target            :type target_cloud: str            :param line_distance: not used            :type line_distance: None            :param target_feature: The path to the input target features            :type target_feature: str            :param target_array: The array of input targets            :type target_array: np.ndarray            :param target_index: The number / id of the target to process            :type target_index: int            :param data_path: not used            :type data_path: None            :param gdb_name: The path to the non-WGS84 project geodatabase            :type gdb_name: str            :param sensor_w: The physical width of the camera sensors' chip            :type sensor_w: float            :param sensor_h: The physical height of the camera sensors' chip            :type sensor_h: float            :param focal: The focal length of the camera's sensor            :type focal: float            :return:            """            # Construct target / observer sight lines            sight_line_out_feature = gdb_name + "/target" + str(target_index) + "_lines"            arcpy.ddd.ConstructSightLines(in_observer_points=target_cloud, in_target_features=target_feature,                                          out_line_feature_class=sight_line_out_feature,                                          observer_height_field="Shape.Z",                                          target_height_field="Shape.Z", output_the_direction=True,                                          sampling_method="3D distance")            # Use search by attribute to remove sight lines outside the specified azimuth and vertical angle            reduced_sight_line_out_feature = gdb_name + "/target" + str(target_index) + "_lines_reduced"            tempLayer = "linesLayer"            arcpy.CopyFeatures_management(sight_line_out_feature, reduced_sight_line_out_feature)            arcpy.MakeFeatureLayer_management(reduced_sight_line_out_feature, tempLayer)            azimuth_min = str(int(target_array[:, 4]))            azimuth_max = str(int(target_array[:, 5]))            pitch_min = str(int(target_array[:, 6]))            pitch_max = str(int(target_array[:, 7]))            if int(pitch_min) and int(pitch_max) > 0:                pitch_min = str(int(pitch_min) * -1)                pitch_max = str(int(pitch_max) * -1)            delta_azimuth = int(azimuth_min) - int(azimuth_max)            expression1 = ["AZIMUTH > " + azimuth_min + " And AZIMUTH < " + azimuth_max,                           "VERT_ANGLE > " + pitch_max + " And VERT_ANGLE < " + pitch_min]            expression2 = ["AZIMUTH < " + azimuth_min + " And AZIMUTH > " + azimuth_max,                           "VERT_ANGLE > " + pitch_max + " And VERT_ANGLE < " + pitch_min]            if delta_azimuth < 0:                arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression1[0])                arcpy.SelectLayerByAttribute_management(tempLayer, "SWITCH_SELECTION")                if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                    arcpy.DeleteFeatures_management(tempLayer)                arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression1[1])                arcpy.SelectLayerByAttribute_management(tempLayer, "SWITCH_SELECTION")                if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                    arcpy.DeleteFeatures_management(tempLayer)            else:                arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression2[0])                if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                    arcpy.DeleteFeatures_management(tempLayer)                arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression2[1])                arcpy.SelectLayerByAttribute_management(tempLayer, "SWITCH_SELECTION")                if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                    arcpy.DeleteFeatures_management(tempLayer)            # Use Near 3D to locate closes obstructing points            arcpy.ddd.Near3D(in_features=reduced_sight_line_out_feature, near_features=las_cloud,                             search_radius="15 Centimeters")            # Remove lines that are within the given nearness threshold to the obstructing points            visible_line_out_feature = gdb_name + "/target" + str(target_index) + "_lines_visible"            tempLayer = "visibleLayer"            arcpy.CopyFeatures_management(reduced_sight_line_out_feature, visible_line_out_feature)            arcpy.MakeFeatureLayer_management(visible_line_out_feature, tempLayer)            distance3d = 0.04            expression = arcpy.AddFieldDelimiters(tempLayer, "NEAR_DIST3") + " > " + "-1" + " And " \                         + arcpy.AddFieldDelimiters(tempLayer, "NEAR_DIST3") + " < " + str(distance3d)            arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression)            if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer)            # Add line length to visible lines            arcpy.ddd.AddZInformation(in_feature_class=visible_line_out_feature, out_property="LENGTH_3D")            # Use Join to Join sight lines to target cloud, keeping only cloud points that match sight lines OID            target_stations_out_feature = gdb_name + "/target" + str(target_index) + "_camera_stations"            target_camera_stations = arcpy.management.AddJoin(in_layer_or_view=target_cloud, in_field="OBJECTID",                                                              join_table=visible_line_out_feature,                                                              join_field="OID_OBSERV",                                                              join_type="KEEP_COMMON")            arcpy.CopyFeatures_management(target_camera_stations, target_stations_out_feature)            # Add target ID to field            arcpy.management.AddField(in_table=target_stations_out_feature, field_name="TargetID", field_type="LONG")            arcpy.management.CalculateField(in_table=target_stations_out_feature, field="TargetID",                                            expression=target_index)            # Delete fields with Drop Field            drop_fields_prefix = "target" + str(target_index) + "_lines_visible_"            drop_fields = [drop_fields_prefix + "OBJECTID", drop_fields_prefix + "OID_OBSERV",                           drop_fields_prefix + "OID_TARGET", drop_fields_prefix + "InLine_FID",                           drop_fields_prefix + "SimLnFlag", drop_fields_prefix + "MaxSimpTol",                           drop_fields_prefix + "MinSimpTol", drop_fields_prefix + "NEAR_FID",                           drop_fields_prefix + "NEAR_DIST",                           drop_fields_prefix + "NEAR_DIST3"]            arcpy.management.DeleteField(in_table=target_stations_out_feature, drop_field=drop_fields)            # Rename fields            azimuth_field = "target" + str(target_index) + "_lines_visible_AZIMUTH"            new_azimuth_field = "AZIMUTH"            vert_angle_field = "target" + str(target_index) + "_lines_visible_VERT_ANGLE"            new_vert_angle_field = "VERT_ANGLE"            length3d_field = "target" + str(target_index) + "_lines_visible_Length3D"            new_length3d_field = "Length3D"            arcpy.management.AlterField(in_table=target_stations_out_feature,                                        field=azimuth_field, new_field_name=new_azimuth_field)            arcpy.management.AlterField(in_table=target_stations_out_feature,                                        field=vert_angle_field, new_field_name=new_vert_angle_field)            arcpy.management.AlterField(in_table=target_stations_out_feature,                                        field=length3d_field, new_field_name=new_length3d_field)            # Calculate new fields for horiz_fov_min/max and vertical_fov_min/max and GSD            arcpy.management.AddField(in_table=target_stations_out_feature, field_name="cam_horiz_fov_min",                                      field_type="DOUBLE")            arcpy.management.AddField(in_table=target_stations_out_feature, field_name="cam_horiz_fov_max",                                      field_type="DOUBLE")            arcpy.management.AddField(in_table=target_stations_out_feature, field_name="cam_vert_fov_min",                                      field_type="DOUBLE")            arcpy.management.AddField(in_table=target_stations_out_feature, field_name="cam_vert_fov_max",                                      field_type="DOUBLE")            horiz_fov_min_expression = "calculate_cam_fov(" + str(focal) + ", " + str(sensor_w) + ", " + str(                sensor_h) + ", !Length3D!, !AZIMUTH!)"            horiz_fov_min_codeblock = """def calculate_cam_fov(focal, sensor_w, sensor_h, sensor_distance, azmth):                horiz_fov_deg = ((sensor_w * sensor_distance) / focal) * 0.5                horiz_fov_deg = horiz_fov_deg - (horiz_fov_deg * 0.05)                horiz_azmth_min = azmth - horiz_fov_deg                if horiz_azmth_min < 0:                    horiz_azmth_min = 360 + horiz_azmth_min                         return horiz_azmth_min"""            arcpy.management.CalculateField(in_table=target_stations_out_feature, field="cam_horiz_fov_min",                                            expression=horiz_fov_min_expression,                                            expression_type="PYTHON3", code_block=horiz_fov_min_codeblock)            horiz_fov_max_expression = "calculate_cam_fov(" + str(focal) + ", " + str(sensor_w) + ", " + str(                sensor_h) + ", !Length3D!, !AZIMUTH!)"            horiz_fov_max_codeblock = """def calculate_cam_fov(focal, sensor_w, sensor_h, sensor_distance, azmth):                horiz_fov_deg = ((sensor_w * sensor_distance) / focal) * 0.5                horiz_fov_deg = horiz_fov_deg - (horiz_fov_deg * 0.05)                horiz_azmth_max = azmth + horiz_fov_deg                if horiz_azmth_max > 360:                    horiz_azmth_max = horiz_azmth_max - 360                return horiz_azmth_max"""            arcpy.management.CalculateField(in_table=target_stations_out_feature, field="cam_horiz_fov_max",                                            expression=horiz_fov_max_expression,                                            expression_type="PYTHON3", code_block=horiz_fov_max_codeblock)            vert_fov_min_expression = "calculate_cam_fov(" + str(focal) + ", " + str(sensor_w) + ", " + str(                sensor_h) + ", !Length3D!, !VERT_ANGLE!)"            vert_fov_min_codeblock = """def calculate_cam_fov(focal, sensor_w, sensor_h, sensor_distance, vert):                vert_fov_deg = ((sensor_h * sensor_distance) / focal) * 0.5                vert_fov_deg = vert_fov_deg - (vert_fov_deg * 0.05)                vert_angle_min = vert + vert_fov_deg                if vert_angle_min > 0:                    vert_angle_min = 0                return vert_angle_min"""            arcpy.management.CalculateField(in_table=target_stations_out_feature, field="cam_vert_fov_min",                                            expression=vert_fov_min_expression,                                            expression_type="PYTHON3", code_block=vert_fov_min_codeblock)            vert_fov_max_expression = "calculate_cam_fov(" + str(focal) + ", " + str(sensor_w) + ", " + str(                sensor_h) + ", !Length3D!, !VERT_ANGLE!)"            vert_fov_max_codeblock = """def calculate_cam_fov(focal, sensor_w, sensor_h, sensor_distance, vert):                vert_fov_deg = ((sensor_h * sensor_distance) / focal) * 0.5                vert_fov_deg = vert_fov_deg - (vert_fov_deg * 0.05)                vert_angle_max = vert - vert_fov_deg                if vert_angle_max < -90:                    vert_angle_max = -90                return vert_angle_max"""            arcpy.management.CalculateField(in_table=target_stations_out_feature, field="cam_vert_fov_max",                                            expression=vert_fov_max_expression,                                            expression_type="PYTHON3", code_block=vert_fov_max_codeblock)        def check_cumulative(all_targets, sensor_w, focal, image_w, las_cloud, gdb_name):            """            Function to evaulate all unobstructed views from camera stations for individual targets against potential            additional targets.            :param all_targets: All targets from the input targets shapefile            :type all_targets: np.ndarray            :param sensor_w: The physical width of the camera sensors' chip            :type sensor_w: float            :param focal: The focal length of the camera's sensor            :type focal: float            :param image_w: The width of a camera image in pixels            :type image_w: int            :param las_cloud: The path to the lidar-based point cloud used for determining obstructions            :type las_cloud: str            :param gdb_name: The path to the non-WGS84 project geodatabase            :type gdb_name: str            :return:            """            target_range = range(1, all_targets.shape[0] + 1)            cam_station_file_list = []            for i in target_range:                cam_station_file_list.append(gdb_name + "/target" + str(i) + "_camera_stations")            merged_stations = gdb_name + "/" + "camera_stations_merged"            arcpy.management.Merge(inputs=cam_station_file_list, output=merged_stations)            out_target_points = gdb_name + "/" + "target_points"            # Add new field for Target to target_points            arcpy.management.AddField(in_table=out_target_points, field_name="Target", field_type="LONG")            arcpy.management.CalculateField(in_table=out_target_points, field="Target", expression="!OBJECTID!")            sight_line_out_feature = gdb_name + "/" + "all_targets_lines"            arcpy.ddd.ConstructSightLines(in_observer_points=merged_stations, in_target_features=out_target_points,                                          out_line_feature_class=sight_line_out_feature,                                          observer_height_field="Shape.Z",                                          target_height_field="Shape.Z", output_the_direction=True,                                          sampling_method="3D distance")            # Join sight lines to merged stations to add the TargetID field            targetid_sight_lines_out_feature = gdb_name + "/" + "all_targetsid_lines"            # Should probably be TargetID from Sight_Line_Out_Feature and ? from merged_stations            targetid_sight_lines = arcpy.management.AddJoin(in_layer_or_view=sight_line_out_feature,                                                            in_field="OID_OBSERV", join_table=merged_stations,                                                            join_field="OBJECTID", join_type="KEEP_ALL")            arcpy.CopyFeatures_management(targetid_sight_lines, targetid_sight_lines_out_feature)            # Add original azmin azmax pmin pmax target constraints for secondary targets            angle_sight_lines_out_feature = gdb_name + "/" + "all_targetsid_angles_lines"            angle_sight_lines = arcpy.management.AddJoin(in_layer_or_view=targetid_sight_lines_out_feature,                                                         in_field="all_targets_lines_OID_TARGET",                                                         join_table=out_target_points,                                                         join_field="Target", join_type="KEEP_ALL")            arcpy.CopyFeatures_management(angle_sight_lines, angle_sight_lines_out_feature)            # Build cumulative angle checks            reduced_all_sight_lines_out_feature = gdb_name + "/" + "all_targetsid_lines_reduced"            tempLayer = "linesLayer"            arcpy.CopyFeatures_management(angle_sight_lines_out_feature, reduced_all_sight_lines_out_feature)            index_fields = ["all_targetsid_lines_all_targets_lines_AZIMUTH",                            "all_targetsid_lines_camera_stations_merged_cam_horiz_fov_min",                            "all_targetsid_lines_camera_stations_merged_cam_horiz_fov_max"]            arcpy.MakeFeatureLayer_management(reduced_all_sight_lines_out_feature, tempLayer)            arcpy.management.AddIndex(in_table=tempLayer, fields=index_fields, index_name="AZMinMax")            expression1 = "all_targetsid_lines_all_targets_lines_AZIMUTH NOT BETWEEN " \                          "all_targetsid_lines_camera_stations_merged_cam_horiz_fov_min " \                          "AND all_targetsid_lines_camera_stations_merged_cam_horiz_fov_max"            expression2 = "all_targetsid_lines_all_targets_lines_VERT_ANGLE NOT BETWEEN " \                          "all_targetsid_lines_camera_stations_merged_cam_vert_fov_max " \                          "AND all_targetsid_lines_camera_stations_merged_cam_vert_fov_min"            expression3 = "all_targetsid_lines_all_targets_lines_AZIMUTH NOT BETWEEN " \                          "target_points_azmin AND target_points_azmax"            expression4 = "all_targetsid_lines_all_targets_lines_VERT_ANGLE NOT BETWEEN " \                          "target_points_pmax AND target_points_pmin"            arcpy.SelectLayerByAttribute_management(tempLayer, "NEW_SELECTION", expression1)            # arcpy.SelectLayerByAttribute_management(tempLayer, "SWITCH_SELECTION")            if int(arcpy.GetCount_management(tempLayer)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer)            tempLayer2 = "linesLayer2"            arcpy.MakeFeatureLayer_management(reduced_all_sight_lines_out_feature, tempLayer2)            index_fields2 = ["all_targetsid_lines_all_targets_lines_VERT_ANGLE",                             "all_targetsid_lines_camera_stations_merged_cam_vert_fov_min",                             "all_targetsid_lines_camera_stations_merged_cam_vert_fov_max"]            arcpy.management.AddIndex(in_table=tempLayer2, fields=index_fields2, index_name="PMinMax")            arcpy.SelectLayerByAttribute_management(tempLayer2, "NEW_SELECTION", expression2)            # arcpy.SelectLayerByAttribute_management(tempLayer2, "SWITCH_SELECTION")            if int(arcpy.GetCount_management(tempLayer2)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer2)            tempLayer3 = "linesLayer3"            arcpy.MakeFeatureLayer_management(reduced_all_sight_lines_out_feature, tempLayer3)            index_fields3 = ["all_targetsid_lines_all_targets_lines_AZIMUTH",                             "target_points_azmin", "target_points_azmax"]            arcpy.management.AddIndex(in_table=tempLayer3, fields=index_fields3, index_name="TAZMinMax")            arcpy.SelectLayerByAttribute_management(tempLayer3, "NEW_SELECTION", expression3)            # arcpy.SelectLayerByAttribute_management(tempLayer2, "SWITCH_SELECTION")            if int(arcpy.GetCount_management(tempLayer3)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer3)            tempLayer4 = "linesLayer4"            arcpy.MakeFeatureLayer_management(reduced_all_sight_lines_out_feature, tempLayer4)            index_fields4 = ["all_targetsid_lines_all_targets_lines_VERT_ANGLE",                             "target_points_pmin", "target_points_pmax"]            arcpy.management.AddIndex(in_table=tempLayer4, fields=index_fields4, index_name="TPMinMax")            arcpy.SelectLayerByAttribute_management(tempLayer4, "NEW_SELECTION", expression4)            # arcpy.SelectLayerByAttribute_management(tempLayer2, "SWITCH_SELECTION")            if int(arcpy.GetCount_management(tempLayer4)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer4)            # Remove lines with single target views            singles_expression = "all_targetsid_lines_all_targets_lines_OID_TARGET = " \                                 "all_targetsid_lines_camera_stations_merged_TargetID"            arcpy.SelectLayerByAttribute_management(tempLayer4, "NEW_SELECTION", singles_expression)            if int(arcpy.GetCount_management(tempLayer3)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer4)            # Add line length to reduced sight lines            arcpy.ddd.AddZInformation(in_feature_class=tempLayer4, out_property="LENGTH_3D")            # Add field for GSD            arcpy.management.AddField(in_table=tempLayer4, field_name="gsd", field_type="DOUBLE")            # Calculate the cumulative target projected GSD            gsd_calculation_expression = "calculate_target_gsd(" + str(focal) + ", " + str(sensor_w) + ", " + str(                image_w) + ", !Length3D!)"            gsd_calculation_codeblock = """def calculate_target_gsd(focal, sensor_w, image_w, length):                gsd = (sensor_w * length) / (focal * image_w)                return gsd"""            arcpy.management.CalculateField(in_table=reduced_all_sight_lines_out_feature, field="gsd",                                            expression=gsd_calculation_expression, expression_type="PYTHON3",                                            code_block=gsd_calculation_codeblock)            # Use Near 3D to locate closes obstructing points            tempLASFC = "LASFCLayer"            arcpy.MakeFeatureLayer_management(las_cloud, tempLASFC)            arcpy.ddd.Near3D(in_features=reduced_all_sight_lines_out_feature, near_features=tempLASFC,                             search_radius="6 Centimeters")            # Remove lines that are within the given nearness threshold to the obstructing points            cumulative_visible_lines_out_feature = gdb_name + "/" + "cumulative_lines_visible"            tempLayer5 = "visibleLayer"            arcpy.CopyFeatures_management(reduced_all_sight_lines_out_feature, cumulative_visible_lines_out_feature)            arcpy.MakeFeatureLayer_management(cumulative_visible_lines_out_feature, tempLayer5)            index_fields5 = ["NEAR_DIST3"]            arcpy.management.AddIndex(in_table=tempLayer5, fields=index_fields5, index_name="NearDistance")            distance3d = 0.04            cumulative_expression = "NEAR_DIST3 > -1 AND NEAR_DIST3 < " + str(distance3d)            # cumulative_expression = arcpy.AddFieldDelimiters(tempLayer2, "NEAR_DIST3") + " > " + "-1" + " And "\            #     + arcpy.AddFieldDelimiters(tempLayer2, "NEAR_DIST3") + " < " + str(distance3d)            arcpy.SelectLayerByAttribute_management(tempLayer5, "NEW_SELECTION", cumulative_expression)            if int(arcpy.GetCount_management(tempLayer5)[0]) > 0:                arcpy.DeleteFeatures_management(tempLayer5)            # Join the lines to the merged camera stations            cumulative_stations_out_feature = gdb_name + "/" + "cumulative_camera_stations"            cumulative_stations = arcpy.management.AddJoin(in_layer_or_view=merged_stations, in_field="OBJECTID",                                                           join_table=cumulative_visible_lines_out_feature,                                                           join_field="all_targetsid_lines_camera_stations_merged_OBJECTID",                                                           join_type="KEEP_COMMON")            arcpy.CopyFeatures_management(cumulative_stations, cumulative_stations_out_feature)            # Clean up cumulative stations fields            drop_fields = ["camera_stations_merged_Length3D",                           "cumulative_lines_visible_all_targetsid_lines_all_targets_lines_A",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_1",                           "cumulative_lines_visible_all_targetsid_lines_all_targets_lines_V",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_2",                           "camera_stations_merged_cam_horiz_fov_min",                           "camera_stations_merged_cam_horiz_fov_max", "camera_stations_merged_cam_vert_fov_min",                           "camera_stations_merged_cam_vert_fov_max",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_5",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_6",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_7",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_8",                           "cumulative_lines_visible_camera_stations_merged_cam_horiz_fov_ma",                           "cumulative_lines_visible_camera_stations_merged_cam_vert_fov_min",                           "cumulative_lines_visible_camera_stations_merged_cam_vert_fov_max",                           "cumulative_lines_visible_target_points_azmin",                           "cumulative_lines_visible_target_points_azmax",                           "cumulative_lines_visible_target_points_pmin", "cumulative_lines_visible_target_points_pmax",                           "cumulative_lines_visible_target_points_Target", "cumulative_lines_visible_NEAR_FID",                           "cumulative_lines_visible_NEAR_DIST", "cumulative_lines_visible_NEAR_DIST3",                           "cumulative_lines_visible_OBJECTID",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_mer",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_4",                           "cumulative_lines_visible_target_points_OBJECTID",                           "cumulative_lines_visible_target_points_gsd",                           "cumulative_lines_visible_all_targetsid_lines_camera_stations_m_3",                           "cumulative_lines_visible_Length3D"]            arcpy.management.DeleteField(in_table=cumulative_stations_out_feature, drop_field=drop_fields)            # Rename fields            azimuth_field = "camera_stations_merged_AZIMUTH"            new_azimuth_field = "AZIMUTH"            vert_angle_field = "camera_stations_merged_VERT_ANGLE"            new_vert_angle_field = "VERT_ANGLE"            targetid_field = "camera_stations_merged_TargetID"            new_targetid_field = "ViewID"            old_cam_station_number_field = "cumulative_lines_visible_all_targetsid_lines_all_targets_lines_O"            new_cam_station_number_field = "Camera_Station_ID"            old_sec_target_field = "cumulative_lines_visible_all_targetsid_lines_all_targets_lines_1"            new_sec_target_field = "SecondaryViewID"            old_gsd_field = "cumulative_lines_visible_gsd"            new_gsd_field = "GSD"            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=azimuth_field, new_field_name=new_azimuth_field)            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=vert_angle_field, new_field_name=new_vert_angle_field)            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=targetid_field, new_field_name=new_targetid_field,                                        new_field_alias="ViewID")            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=old_cam_station_number_field, new_field_name=new_cam_station_number_field,                                        new_field_alias="CamStatID")            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=old_sec_target_field, new_field_name=new_sec_target_field,                                        new_field_alias="SecondaryViewID")            arcpy.management.AlterField(in_table=cumulative_stations_out_feature,                                        field=old_gsd_field, new_field_name=new_gsd_field)        def prepare_cumulative_count(wgs84stations, new_geodb):            """            Function to add cumulative view count fields to cumulative camera stations feature class            :param wgs84stations: Path to the cumulative camera stations feature class            :type wgs84stations: str            :param new_geodb: Path to the WGS84 project geodatabase            :type new_geodb: str            :return: cumulative_stations_count: Path to the new cumulative camera stations feature class that includes                view count fields            :rtype: str            """            cumulative_stations = new_geodb + "/" + "cumulative_stations"            arcpy.conversion.FeatureClassToFeatureClass(in_features=wgs84stations,                                                        out_path=new_geodb,                                                        out_name="cumulative_stations")            cumulative_stations_count = new_geodb + "/" + "cumulative_stations_count"            arcpy.management.Sort(in_dataset=cumulative_stations, out_dataset=cumulative_stations_count,                                  sort_field="Camera_Station_ID")            for i in range(2, 11):                new_field = "Views_" + str(i)                arcpy.management.AddField(in_table=cumulative_stations_count, field_name=new_field, field_type="SHORT")            fields = ["Views_2", "Views_3", "Views_4", "Views_5", "Views_6", "Views_7", "Views_8", "Views_9",                      "Views_10"]            arcpy.management.CalculateField(in_table=cumulative_stations_count, field=fields[0], expression="1",                                            expression_type="PYTHON3")            return cumulative_stations_count        def calculate_cumulative_station_count(featureclass, viewsnumber):            """            Function to calculate the number of secondary targets (views) visible from each cumulative camera station            :param featureclass: The path to the cumulative_stations_count            :type featureclass: str            :param viewsnumber: The number of views to check for            :type viewsnumber: int            :return:            """            viewsfield = "Views_" + str(viewsnumber)            counter_subtractor = viewsnumber - 2            counter = 0            list_vals = []            new_val = []            with arcpy.da.SearchCursor(featureclass, ['OID@', 'Camera_Station_ID']) as cursor:                for row in cursor:                    if counter == 0:                        new_val.append(0)                        list_vals.append(row[1])                        counter += 1                    else:                        try:                            if list_vals[counter - counter_subtractor] == row[1]:                                new_val.append(1)                            else:                                new_val.append(0)                        except:                            new_val.append(0)                            pass                        list_vals.append(row[1])                        counter += 1            counter = 0            with arcpy.da.UpdateCursor(featureclass, [viewsfield]) as cursor:                for row in cursor:                    new_value = new_val[counter]                    if new_value == 0:                        row[0] = 0                    else:                        row[0] = 1                    cursor.updateRow(row)                    counter += 1        def find_unique_cam_target_views(stations, targetfeatures):            """            Function to determine which camera stations have singular, individual views of a target and which have views                of multiple targets            :param stations: The path to the cumulative_stations_count            :type stations: str            :param targetfeatures: The path to the input targets shapefile            :type targetfeatures: str            :return: unique_views: a list of unique views from the cumulative camera stations            :rtype: list            :return: target_views: a list of ALL views (targets)            :rtype: list            :return: primary_only_views: a list of unique views from the individual views            :rtype: list            """            unique_views = []            with arcpy.da.SearchCursor(stations, ['ViewID', 'SecondaryViewID']) as cursor:                for row in cursor:                    if row[0] not in unique_views:                        unique_views.append(row[0])                    if row[1] not in unique_views:                        unique_views.append(row[1])            unique_views.sort()            target_views = []            with arcpy.da.SearchCursor(targetfeatures, ['ViewID']) as cursor:                for row in cursor:                    if row[0] not in target_views:                        target_views.append(row[0])            target_views.sort()            primary_only_views = []            for i in target_views:                if i not in unique_views:                    primary_only_views.append(i)            return unique_views, target_views, primary_only_views        def find_3d_center_point(primary_target_view, original_geodb):            """            Function to find the center-most camera station in a group of stations for a single target            :param primary_target_view: A target view number from the primary_only_views            :type primary_target_view: int            :param original_geodb: Path to the non-WGS84 project geodatabase            :type original_geodb: str            :return:            """            primary_target_feature_class = original_geodb + "/" + "target" + str(                primary_target_view) + "_camera_stations"            temp_output_polygon = original_geodb + "/temp_3d_polygon_" + str(primary_target_view)            temp_output_point = original_geodb + "/temp_point_" + str(primary_target_view)            temp_output_3d_point = original_geodb + "/temp_3d_point_" + str(primary_target_view)            if int(arcpy.GetCount_management(primary_target_feature_class)[0]) < 6:                try:                    target_selected_feature_class = original_geodb + "/" + "target" + str(                        primary_target_view) + "_selected"                    temp_layer_name = "TargetLayer_" + str(primary_target_view)                    arcpy.CopyFeatures_management(primary_target_feature_class, target_selected_feature_class)                    arcpy.MakeFeatureLayer_management(target_selected_feature_class, temp_layer_name)                    expression = "OBJECTID <> 1"                    arcpy.SelectLayerByAttribute_management(temp_layer_name, "NEW_SELECTION", expression)                    if int(arcpy.GetCount_management(temp_layer_name)[0]) > 0:                        arcpy.DeleteFeatures_management(temp_layer_name)                    # Remove temporary files                    arcpy.Delete_management(in_data=temp_output_polygon)                    arcpy.Delete_management(in_data=temp_output_point)                    arcpy.Delete_management(in_data=temp_output_3d_point)                    arcpy.Delete_management(temp_layer_name, 'GPFeatureLayer')                    # Remove temporary fields                    drop_fields = ["NEAR_FID", "NEAR_DIST", "NEAR_DIST3"]                    arcpy.DeleteField_management(in_table=primary_target_feature_class, drop_field=drop_fields)                except:                    pass            else:                # Create 3D polygon around camera stations                arcpy.MinimumBoundingVolume_3d(in_features=primary_target_feature_class, z_value="Shape.Z",                                               out_feature_class=temp_output_polygon, geometry_type="CONVEX_HULL",                                               group="ALL")                # Add the average Z value to the 3D polygon                arcpy.AddZInformation_3d(in_feature_class=temp_output_polygon, out_property="Z_MEAN")                # Find the centroid of the 3D polygon and export as a point                arcpy.management.FeatureToPoint(in_features=temp_output_polygon, out_feature_class=temp_output_point,                                                point_location="CENTROID")                # Convert the point to pointz using the average z value from the polygon                arcpy.FeatureTo3DByAttribute_3d(in_features=temp_output_point, out_feature_class=temp_output_3d_point,                                                height_field="Z_MEAN")                # Distance of all camera stations to the center of all camera stations                arcpy.Near3D_3d(in_features=primary_target_feature_class, near_features=temp_output_3d_point)                # Find the minimum 3D distance between camera stations and the center                minimum_distance_list = []                with arcpy.da.SearchCursor(primary_target_feature_class, ['NEAR_DIST3']) as cursor:                    for row in cursor:                        minimum_distance_list.append(row[0])                minimum_distance_list.sort()                minimum_distance = minimum_distance_list[0]                minimum_distance = round(minimum_distance, 6) + 0.0001                # Select and export the camera station closest to the center of all camera stations                target_selected_feature_class = original_geodb + "/" + "target" + str(primary_target_view) + "_selected"                temp_layer_name = "TargetLayer_" + str(primary_target_view)                arcpy.CopyFeatures_management(primary_target_feature_class, target_selected_feature_class)                arcpy.MakeFeatureLayer_management(target_selected_feature_class, temp_layer_name)                minimum_expression = "NEAR_DIST3 > " + str(minimum_distance)                arcpy.SelectLayerByAttribute_management(temp_layer_name, "NEW_SELECTION", minimum_expression)                if int(arcpy.GetCount_management(temp_layer_name)[0]) > 0:                    arcpy.DeleteFeatures_management(temp_layer_name)                # Remove temporary files                arcpy.Delete_management(in_data=temp_output_polygon)                arcpy.Delete_management(in_data=temp_output_point)                arcpy.Delete_management(in_data=temp_output_3d_point)                arcpy.Delete_management(temp_layer_name, 'GPFeatureLayer')                # Remove temporary fields                drop_fields = ["NEAR_FID", "NEAR_DIST", "NEAR_DIST3"]                arcpy.DeleteField_management(in_table=primary_target_feature_class, drop_field=drop_fields)                arcpy.DeleteField_management(in_table=target_selected_feature_class, drop_field=drop_fields)        def extract_cumulative_waypoints(cumulative_stations, cumulative_list, new_geodb):            """            Function to find and extract cumulative waypoints that can see the most targets, while ensuring that all                cumulative targets get at least 1 view and that views are not needlessly repeated by other camera                stations.            :param cumulative_stations: Path to the cumulative_stations_count feature class            :type cumulative_stations: str            :param cumulative_list: The list of cumulative camera stations from unique_views            :type cumulative_list: list            :param new_geodb: Path to the WGS84 project geodatabase            :type new_geodb: str            :return: cumulative_waypoints_selected: Path to the cumulative camera stations that were selected by this                process            :rtype: str            """            cumulative_waypoints_selected = new_geodb + "/" + "cumulative_waypoints"            view_counts = ["Views_10", "Views_9", "Views_8", "Views_7", "Views_6", "Views_5", "Views_4", "Views_3"]            field_names = ["Camera_Station_ID", "ViewID", "SecondaryViewID", "Views_3", "Views_4", "Views_5", "Views_6",                           "Views_7", "Views_8", "Views_9", "Views_10"]            # Calculate and add a 1 for the number of cumulative views from each record            for index in view_counts:                selected_stations = []                with arcpy.da.SearchCursor(cumulative_stations, ["Camera_Station_ID", str(index)]) as cursor:                    for row in cursor:                        if row[1] == 1:                            selected_stations.append(row[0])                with arcpy.da.UpdateCursor(cumulative_stations, ["Camera_Station_ID", str(index)]) as cursor:                    for row in cursor:                        if row[0] in selected_stations:                            row[1] = 1                            cursor.updateRow(row)            # Select camera stations with the most cumulative views ensuring every cumulative target has a station            view_counts2 = ["Views_10", "Views_9", "Views_8", "Views_7", "Views_6", "Views_5", "Views_4", "Views_3",                            "Views_2"]            camera_station_view_counts = {}            for i in cumulative_list:                for j in view_counts2:                    with arcpy.da.SearchCursor(cumulative_stations,                                               ["Camera_Station_ID", "ViewID", "SecondaryViewID", j]) as cursor:                        for row in cursor:                            if row[3] == 1:                                if i == row[1] or i == row[2]:                                    if i in camera_station_view_counts.keys():                                        continue                                    else:                                        camera_station_view_counts[i] = [row[0], row[1], row[2]]            camera_station_view_counts_df = pd.DataFrame.from_dict(camera_station_view_counts, orient='index',                                                                   columns=["CameraStation", "PrimaryView",                                                                            "SecondaryView"])            # Save the cumulative waypoint views to an excel file and geodatabase table            excel_path = os.path.split(new_geodb)[0]            excel_name = excel_path + "/cumulative_waypoint_views.xlsx"            camera_station_view_counts_df.to_excel(excel_name)            arcpy.ExcelToTable_conversion(Input_Excel_File=excel_name,                                          Output_Table=new_geodb + "/cumulative_waypoint_views")            unique_cumulative_stations_list = []            for i in camera_station_view_counts:                unique_cumulative_stations_list.append(camera_station_view_counts[i][0])            unique_cumulative_stations_list.sort()            unique_cumulative_stations_list2 = []            for i in unique_cumulative_stations_list:                if i not in unique_cumulative_stations_list2:                    unique_cumulative_stations_list2.append(i)            unique_cumulative_stations_list2.sort()            # Create a new feature class of just the cumulative stations selected from the above process            temp_layer_name = "Temp_Cumulative_Layer"            arcpy.CopyFeatures_management(cumulative_stations, cumulative_waypoints_selected)            arcpy.MakeFeatureLayer_management(cumulative_waypoints_selected, temp_layer_name)            temp_camera_station_list = []            with arcpy.da.SearchCursor(temp_layer_name, ["OBJECTID", "Camera_Station_ID"]) as cursor:                for row in cursor:                    if row[1] not in unique_cumulative_stations_list2:                        expression = "OBJECTID = " + str(row[0])                        arcpy.SelectLayerByAttribute_management(temp_layer_name, "NEW_SELECTION", expression)                        if int(arcpy.GetCount_management(temp_layer_name)[0]) > 0:                            arcpy.DeleteFeatures_management(temp_layer_name)                        continue                    elif row[1] in unique_cumulative_stations_list2 and row[1] not in temp_camera_station_list:                        temp_camera_station_list.append(row[1])                        continue                    elif row[1] in unique_cumulative_stations_list2 and row[1] in temp_camera_station_list:                        expression = "OBJECTID = " + str(row[0])                        arcpy.SelectLayerByAttribute_management(temp_layer_name, "NEW_SELECTION", expression)                        if int(arcpy.GetCount_management(temp_layer_name)[0]) > 0:                            arcpy.DeleteFeatures_management(temp_layer_name)            return cumulative_waypoints_selected        def merge_selected_stations(primary_selections, cumulative_selections, original_geodb, wgs84_geodb):            """            Function to merge the individual target camera stations with the selected cumulative target camera stations            and export all to WGS84 for use in UAS flight-planning            :param primary_selections: A list of individual views from primary_only_views            :type primary_selections: list            :param cumulative_selections: The path to the selected cumulative stations from                cumulative_waypoints_selected            :type cumulative_selections: str            :param original_geodb: Path to the non-WGS84 project geodatabase            :type original_geodb: str            :param wgs84_geodb: Path to the WGS84 project geodatabase            :type wgs84_geodb: str            :return:            """            cam_station_file_list = []            for i in primary_selections:                cam_station_file_list.append(original_geodb + "/target" + str(i) + "_selected")            merged_primary = original_geodb + "/" + "merged_primary_waypoints"            merged_wgs84_primary = wgs84_geodb + "/" + "selected_primary_views"            arcpy.management.Merge(inputs=cam_station_file_list, output=merged_primary)            export_to_wgs84(new_gdb=new_geodatabase_name, features=merged_primary, feature_type="selected")            arcpy.management.AlterField(in_table=merged_wgs84_primary, field="TargetID", new_field_name="ViewID",                                        new_field_alias="ViewID")            cumulative_and_primary_selects = [merged_wgs84_primary, cumulative_selections]            merged_primary_and_cumulative_selections = wgs84_geodb + "/" + "camera_waypoints"            arcpy.management.Merge(inputs=cumulative_and_primary_selects,                                   output=merged_primary_and_cumulative_selections)            # Clean up merged stations fields            drop_fields = ["cam_horiz_fov_min", "cam_horiz_fov_max", "cam_vert_fov_min", "cam_vert_fov_max",                           "SecondaryViewID", "GSD", "Views_10", "Views_9", "Views_8", "Views_7", "Views_6", "Views_5",                           "Views_4", "Views_3", "Views_2", "Length3D"]            arcpy.DeleteField_management(in_table=merged_primary_and_cumulative_selections, drop_field=drop_fields)        """The next section runs the tools' functions"""        # Load target shapefile        targets = load_targets(target_file)        # Center the LAS point cloud and targets around a local coordinate        las_cloud_scaled, new_x, new_y, new_z, las_scaler = center_points(las_points, features=False)        targets_scaled, new_x_t, new_y_t, new_z_t, target_scaler = center_points(targets,                                                                                 new_x, new_y, new_z, features=True)        # Convert the targets to a feature class        out_target_points = geodatabase_name + "/" + "target_points"        convert_points_to_feature_class(targets, out_target_points, spatial_reference)        # Convert the LAS file to a multipoint feature class        output_las_multipoints = geodatabase_name + "/" + "las_multipoint"        arcpy.ddd.LASToMultipoint(input=las_input_file, out_feature_class=output_las_multipoints,                                  average_point_spacing=0.02, _return="ANY_RETURNS",                                  input_coordinate_system=spatial_reference)        # Remove las points that are on the targets        output_las_multipoints = remove_near_targets(target_feature_class=out_target_points,                                                     las_multipoint_features=output_las_multipoints)        # Create target point clouds, subsample by voxel size and assess for target visibility        target_count = 1        array_count = 0        for i in targets:            target = targets_scaled[array_count]            target_point_cloud, single_target, distance = create_feature_cloud(target, angular_resolution, focal_length,                                                                               sensor_width, image_width, sensor_height)            target_cloud_centroids = target_subsampling(target_point_cloud, camera_station_voxel_size)            target_cloud_centroids_original_crs = uncenter_points(target_cloud_centroids, target_scaler)            out_target_stations = geodatabase_name + "/" + "target" + str(target_count) + "_stations"            convert_points_to_feature_class(target_cloud_centroids_original_crs, out_target_stations, spatial_reference)            target_fc = targets[array_count].reshape((1, 8))            out_target_point = geodatabase_name + "/" + "target" + str(target_count) + "_point"            convert_points_to_feature_class(target_fc, out_target_point, spatial_reference)            check_visibility(las_cloud=output_las_multipoints, target_cloud=out_target_stations, line_distance=distance,                             target_feature=out_target_point, target_array=target_fc, target_index=target_count,                             gdb_name=geodatabase_name, sensor_w=sensor_width, sensor_h=sensor_height,                             focal=focal_length)            arcpy.AddMessage("finished target visibility check for " + str(target_count))            target_count += 1            array_count += 1        # Perform cumulative target visibility analysis        arcpy.AddMessage("beginning cumulative analysis")        check_cumulative(all_targets=targets, sensor_w=sensor_width, focal=focal_length, image_w=image_width,                         las_cloud=output_las_multipoints, gdb_name=geodatabase_name)        target_range = range(1, targets.shape[0] + 1)        targets_fc_list = []        for i in target_range:            target_name = geodatabase_name + "/target" + str(i) + "_camera_stations"            targets_fc_list.append(target_name)        cumulative_stations_out_feature = geodatabase_name + "/" + "cumulative_camera_stations"        # Convert all data to WGS84 in the WGS84 project geodatabase        export_to_wgs84(new_gdb=new_geodatabase_name, features=targets_fc_list, feature_type="targets")        export_to_wgs84(new_gdb=new_geodatabase_name, features=cumulative_stations_out_feature,                        feature_type="cumulative")        cumulative_stations_wgs84 = new_geodatabase_name + "/" + "cumulative_camera_stations"        # Count the number of secondary targets visible for each cumulative camera station        cumulative_stations_count = prepare_cumulative_count(cumulative_stations_wgs84, new_geodatabase_name)        # Remove unneeded temporary features from project_geodatabase        arcpy.AddMessage("removing temporary features from project_geodatabase")        for i in target_range:            temp_lines = geodatabase_name + "/target" + str(i) + "_lines"            temp_lines_reduced = geodatabase_name + "/target" + str(i) + "_lines_reduced"            temp_stations = geodatabase_name + "/target" + str(i) + "_stations"            arcpy.Delete_management(in_data=temp_lines)            arcpy.Delete_management(in_data=temp_lines_reduced)            arcpy.Delete_management(in_data=temp_stations)        for i in range(3, 11):            calculate_cumulative_station_count(cumulative_stations_count, i)        cumulated_views, targets_views, primary_views = find_unique_cam_target_views(cumulative_stations_count,                                                                                     target_file)        # Select the individual camera stations for singular targets that had no cumulative views        for i in primary_views:            find_3d_center_point(primary_target_view=i, original_geodb=geodatabase_name)        for i in primary_views:            temp_output_polygon = geodatabase_name + "/temp_3d_polygon_" + str(i)            temp_output_point = geodatabase_name + "/temp_point_" + str(i)            temp_output_3d_point = geodatabase_name + "/temp_3d_point_" + str(i)            target_selected = geodatabase_name + "/" + "target" + str(i) + "_selected"            arcpy.Delete_management(in_data=temp_output_polygon)            arcpy.Delete_management(in_data=temp_output_point)            arcpy.Delete_management(in_data=temp_output_3d_point)        # Select the camera stations with the most cumulative views while ensuring all targets are acquired        arcpy.AddMessage("extracting cumulative waypoints")        cumulative_waypoints = extract_cumulative_waypoints(cumulative_stations_count, cumulated_views,                                                            new_geodatabase_name)        # Merge all individual and cumulative camera stations into a single feature class        arcpy.AddMessage("merging cumulative and individual waypoints")        merge_selected_stations(primary_selections=primary_views, cumulative_selections=cumulative_waypoints,                                original_geodb=geodatabase_name, wgs84_geodb=new_geodatabase_name)        returnclass SimilarStructure(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Use Waypoints on Similar Structure"        self.description = "Moves and rotates camera stations for use on a similar structure configuration"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        input_waypoints = arcpy.Parameter(            displayName="Input Waypoints",            name="input_waypoints",            datatype="DEFeatureClass",            parameterType="Required",            direction="Input")        project_geodatabase_wgs84 = arcpy.Parameter(            displayName="Input Project GeoDatabase (WGS84)",            name="project_geodatabase_wgs84",            datatype="DEWorkspace",            parameterType="Required",            direction="Input")        project_geodatabase_wgs84.filter.list = ["Local Database"]        output_name = arcpy.Parameter(            displayName="Input New Feature Class Name",            name="output_name",            datatype="GPString",            parameterType="Required",            direction="Input")        input_origin_x = arcpy.Parameter(            displayName="Input Original Structure Center Longitude (WGS84)",            name="input_origin_x",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_origin_y = arcpy.Parameter(            displayName="Input Original Structure Center Latitude (WGS84)",            name="input_origin_y",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_origin_z = arcpy.Parameter(            displayName="Input Original Structure Ground Elevation (HAE Meters)",            name="input_origin_z",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_new_x = arcpy.Parameter(            displayName="Input New Structure Center Longitude (WGS84)",            name="input_new_x",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_new_y = arcpy.Parameter(            displayName="Input New Structure Center Latitude (WGS84)",            name="input_new_y",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_new_z = arcpy.Parameter(            displayName="Input New Structure Ground Elevation (HAE Meters)",            name="input_new_z",            datatype="GPDouble",            parameterType="Required",            direction="Input")        input_rotation = arcpy.Parameter(            displayName="Input Rotation Angle (Degrees)",            name="input_rotation",            datatype="GPDouble",            parameterType="Required",            direction="Input")        params = [input_waypoints, project_geodatabase_wgs84, output_name, input_origin_x, input_origin_y,                  input_origin_z, input_new_x, input_new_y, input_new_z, input_rotation]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """This tool moves camera waypoints created for 1 structure with the "Run MYOModel" tool to another similar        similar structure. It does this through the following process:        1) Calculates the latitude, longitude and elevation difference between the original structure and the similar            structure        2) Uses the difference to move the waypoints to the similar structure        3) Rotates all points at the new structure based on a specified rotation angle"""        warnings.filterwarnings("ignore", category=DeprecationWarning)        # Load parameters from ArcGIS into python-friendly variables        waypoints = parameters[0].ValueAsText        project_geodb = parameters[1].ValueAsText        new_waypoints = parameters[2].ValueAsText        input_x = float(parameters[3].ValueAsText)        input_y = float(parameters[4].ValueAsText)        input_z = float(parameters[5].ValueAsText)        new_x = float(parameters[6].ValueAsText)        new_y = float(parameters[7].ValueAsText)        new_z = float(parameters[8].ValueAsText)        rotation_angle = float(parameters[9].ValueAsText)        input_xy = [input_x, input_y]        new_xy = [new_x, new_y]        def calculate_difference(orig_xy, orig_z, out_xy, out_z):            """            Function that finds the difference between the original structure's and similar structure's longitudes,            latitudes, and elevations            :param orig_xy: A list containing the original structure's center longitude and latitude coordinates            :type orig_xy: list            :param orig_z: The elevation of on the ground and at the center of the original structure            :type orig_z: float            :param out_xy: A list containing the similar structure's center longitude and latitude coordinates            :type out_xy: list            :param out_z: The elevation of on the ground and at the center of the similar structure            :type out_z: float            :return: A list containing the longitude, latitude and elevation differences            :rtype: list            """            x_diff = float(out_xy[0]) - float(orig_xy[0])            y_diff = float(out_xy[1]) - float(orig_xy[1])            z_diff = out_z - orig_z            return [x_diff, y_diff, z_diff]        def move_points(points, new_points, geodb, origin_diff):            """            Function that moves the longitudes, latitudes and elevations of camera waypoints from the original to the            similar structure            :param points: The feature class path containing the camera waypoints for the original structure            :type points: str            :param new_points: The name for the newly created camera waypoints            :type new_points: str            :param geodb: The geodatabase path to read and write feature classes            :type geodb: str            :param origin_diff: A list returned by calculate_difference()            :type origin_diff: list            :return: moved_waypoints: The path to the temporary feature class containing the newly moved waypoints            :rtype: str            """            moved_waypoints = geodb + "/" + new_points + "_temp"            arcpy.CopyFeatures_management(points, moved_waypoints)            fields = ["SHAPE@X", "SHAPE@Y", "SHAPE@Z", "POINT_X", "POINT_Y", "POINT_Z"]            with arcpy.da.UpdateCursor(moved_waypoints, fields) as cursor:                for row in cursor:                    replace_x = row[0] + origin_diff[0]                    replace_y = row[1] + origin_diff[1]                    replace_z = row[2] + origin_diff[2]                    row[0] = replace_x                    row[1] = replace_y                    row[2] = replace_z                    row[3] = replace_x                    row[4] = replace_y                    row[5] = replace_z                    cursor.updateRow(row)            return moved_waypoints        def load_points(feature_class, geodb):            """            Function that loades the moved waypoints into an array for easy rotation            :param feature_class: The path to the temporary moved waypoints features from move_points()            :type feature_class: str            :param geodb: The path to the geodatabase            :type geodb: str            :return: moved_points: An array of the moved points            :rtype: np.ndarray            """            layer_name = os.path.basename(feature_class)            points_dataframe = gpd.read_file(geodb, layer=layer_name)            points_list = []            for index, values in points_dataframe.iterrows():                x, y, z, azimuth, pitch = points_dataframe.loc[index].geometry.x, \                                                         points_dataframe.loc[index].geometry.y, \                                                         points_dataframe.geometry.loc[index].z, \                                                         points_dataframe.loc[index].AZIMUTH, \                                                         points_dataframe.loc[index].VERT_ANGLE                points_list.append([x, y, z, azimuth, pitch])            moved_points = np.array(points_list)            return moved_points        def rotate_points(points, out_xy, angle):            """            Function that rotates the moved points around the similar structures center coordinate and assigns the new            points new coordinates based on the rotation            :param points: The array of moved points from load_points()            :type points: np.ndarray            :param out_xy: List containing the longitude and latitude coordinates of the center of the similar structure            :type out_xy: list            :param angle: The rotation angle to apply to the points in degrees            :type angle: float            :return: rotated_points_xy: An array containing the new coordinates of the rotated points            :rtype: np.ndarray            """            radian_angle = np.deg2rad(angle)            origin_xy = (out_xy[0], out_xy[1])            rotation_array = np.array([[np.cos(radian_angle), -np.sin(radian_angle)],                                       [np.sin(radian_angle), np.cos(radian_angle)]])            origin_array = np.atleast_2d(origin_xy)            points_2d_array = np.atleast_2d(points[:, 0:2])            rotated_points_xy = np.squeeze((rotation_array @ (points_2d_array.T-origin_array.T) + origin_array.T).T)            return rotated_points_xy        def update_waypoints_rotation(rotated_points, moved_points, angle, new_points, geodb):            """            Function that creates the new camera waypoints for the similar structure from the rotated points            :param rotated_points: The array of rotated points            :type rotated_points: np.ndarray            :param moved_points: The path to the temporary feature class containing the previously moved points            :type moved_points: str            :param angle: The rotation angle in degrees            :type angle: float            :param new_points: The name of the new camera waypoints feature class for the similar structure            :type new_points: str            :param geodb: The path to the project geodatabase            :type geodb: str            :return:            """            radian_rotation_angle = math.radians(angle)            new_waypoints_rotated = geodb + "/" + new_points            arcpy.CopyFeatures_management(moved_points, new_waypoints_rotated)            fields = ["OBJECTID", "SHAPE@X", "SHAPE@Y", "AZIMUTH", "POINT_X", "POINT_Y"]            with arcpy.da.UpdateCursor(new_waypoints_rotated, fields) as cursor:                for row in cursor:                    rotated_points_index = int(row[0]) - 1                    row[1] = rotated_points[rotated_points_index, 0]                    row[2] = rotated_points[rotated_points_index, 1]                    current_azimuth_radians = math.radians(row[3])                    new_azimuth = math.degrees(current_azimuth_radians - radian_rotation_angle)                    if new_azimuth < 0:                        new_azimuth = 360 + new_azimuth                    row[3] = new_azimuth                    row[4] = rotated_points[rotated_points_index, 0]                    row[5] = rotated_points[rotated_points_index, 1]                    cursor.updateRow(row)        differences = calculate_difference(orig_xy=input_xy, orig_z=input_z, out_xy=new_xy, out_z=new_z)        xy_moved_waypoints = move_points(points=waypoints, new_points=new_waypoints, geodb=project_geodb,                                         origin_diff=differences)        moved_points_array = load_points(feature_class=xy_moved_waypoints, geodb=project_geodb)        xy_rotated_points = rotate_points(points=moved_points_array, out_xy=new_xy, angle=rotation_angle)        update_waypoints_rotation(rotated_points=xy_rotated_points, moved_points=xy_moved_waypoints,                                  angle=rotation_angle, new_points=new_waypoints, geodb=project_geodb)        arcpy.Delete_management(in_data=xy_moved_waypoints)        return